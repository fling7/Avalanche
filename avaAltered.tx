///////////////////////////////////////////////////////
// AVALANCHE-inspirierte Movement-DSL (Vollausbau)
///////////////////////////////////////////////////////

///////////////////////////////////////////////////////
// 1) TOP-LEVEL: Model, Package, Imports, heterogene Elemente
///////////////////////////////////////////////////////

Model:
    'model' name=ID
    ('package' package=FQN)?
    imports*=Import
    '{'
        elements*=Element
    '}'
;

FQN: ID ('.' ID)*;

Import:
    'import' imported=FQN ('as' alias=ID)? ';'
;

Element:
      TypeDef | RecordType | EnumType | ConstDecl | VarDecl
    | DistDef | FunctionDef
    | Message | Actor | Channel
    | Event | Trigger
    | MovementScenario
    | StateMachine
    | TimeConstraint | Causality | Concurrency
    | Lifecycle
    | Zone | SpatialRule
    | PropertyDecl | NFRDecl
    | TestCase
    | SimulationConfig | Scheduler
;

Direction: 'in' | 'out';
SyncMode: 'all' | 'any';
ConcurrencyKind: 'parallel' | 'exclusive' | 'alternative';

///////////////////////////////////////////////////////
// 2) ANNOTATIONEN (für NFP, Meta, Traceability)
///////////////////////////////////////////////////////

Annotation:
    '@' name=ID ('(' args+=AnnotationArg (',' args+=AnnotationArg)* ')')?
;

AnnotationArg:
    name=ID '=' value=Literal
;

///////////////////////////////////////////////////////
// 3) TYP-SYSTEM (vollständig: Alias, Record, Enum, Arrays)
///////////////////////////////////////////////////////

TypeDef:
    'type' name=ID '=' target=TypeRef ';'
;

RecordType:
    'record' name=ID '{'
        fields*=FieldDef
    '}'
;

FieldDef:
    name=ID ':' type=TypeRef ('=' default=Expr)? ';'
;

EnumType:
    'enum' name=ID '{'
        literals+=ID (',' literals+=ID)*
    '}'
;

TypeRef:
      BasicType
    | ArrayType
    | typedef=[TypeDef]
    | record=[RecordType]
    | enum=[EnumType]
;

BasicType:
      'int'
    | 'float'
    | 'bool'
    | 'string'
    | 'duration'
    | 'distance'
    | 'speed'
    | 'angle'
    | 'time'
    | 'probability'
;

ArrayType:
    base=TypeRef '[]'
;

ConstDecl:
    'const' name=ID ':' type=TypeRef '=' value=Expr ';'
;

VarDecl:
    'var' name=ID ':' type=TypeRef ('=' init=Expr)? ';'
;

///////////////////////////////////////////////////////
// 4) FUNKTIONEN / AKTIONEN (wiederverwendbare Aktionen)
///////////////////////////////////////////////////////

FunctionDef:
    'function' name=ID '(' (params+=Param (',' params+=Param)*)? ')'
    (':' returnType=TypeRef)?
    (annotations+=Annotation)*
    body=ActionBlock
;

Param:
    name=ID ':' type=TypeRef ('=' default=Expr)?
;

///////////////////////////////////////////////////////
// 5) DISTRIBUTIONEN (dist name = kind(...))
///////////////////////////////////////////////////////

DistDef:
    'dist' name=ID '=' kind=ID '(' (params+=Expr (',' params+=Expr)*)? ')' ';'
;

///////////////////////////////////////////////////////
// 6) KOMMUNIKATION: Actor, Message, Channel, Ports
///////////////////////////////////////////////////////

Message:
    'message' name=ID '{'
        fields*=FieldDef
    '}'
;

Actor:
    'actor' name=ID
    (annotations+=Annotation)*
    '{'
        items*=ActorItem
    '}'
;

ActorItem:
      Port
    | VarDecl
    | ConstDecl
    | FunctionDef
    | Trigger
;

Port:
    direction=Direction 'port' name=ID ':' message=[Message]
    ('latency' '=' latency=DurationLiteral)?
    ('capacity' '=' capacity=INT)?
    ('loss' '=' loss=ProbabilityLiteral)?
    ';'
;

Channel:
    'channel' name=ID '{'
        'from' src=[Port]
        'to'   dst=[Port]
        ('latency' '=' latency=DurationLiteral)?
        ('capacity' '=' capacity=INT)?
        ('loss' '=' loss=ProbabilityLiteral)?
    '}'
;

///////////////////////////////////////////////////////
// 7) EVENTS & TRIGGER (mit Guards, Payload, Verteilungen)
///////////////////////////////////////////////////////

Event:
    'event' name=ID
    '(' (params+=Param (',' params+=Param)*)? ')'
    '{'
        ('type' ':' eventType=ID ';')?
        ('probability' '=' prob=ProbabilityLiteral ';')?
        ('arrival' '=' dist=[DistDef] ';')?
        ('payload' ':' payloadType=TypeRef ';')?
    '}'
;

Trigger:
    'trigger' name=ID?
    'on' event=[Event]
    ('when' guard=Expr)?
    'do' action=ActionBlock
;

///////////////////////////////////////////////////////
// 8) SZENARIEN & STEPS (Action, Choice, Parallel, Wait, Sync, Expect)
///////////////////////////////////////////////////////

MovementScenario:
    'scenario' name=ID
    (annotations+=Annotation)*
    '{'
        locals*=ScenarioLocal
        steps*=Step
    '}'
;

ScenarioLocal:
      VarDecl
    | ConstDecl
;

Step:
      StepDuration
    | StepDistance
    | ActionStep
    | WaitStep
    | ChoiceStep
    | ParallelStep
    | SyncStep
    | ExpectStep
;

StepDuration:
    'stepDuration' name=ID?
    'for' duration=DurationLiteral
    ('using' distribution=[DistDef])?
    ';'
;

StepDistance:
    'stepDistance' name=ID?
    'distance' distance=DistanceLiteral
    ('using' distribution=[DistDef])?
    ';'
;

ActionStep:
    'step' name=ID 'do' action=ActionBlock
;

WaitStep:
    'wait'
    (('for' duration=DurationLiteral) | ('until' event=[Event]))
    ';'
;

ChoiceStep:
    'choice' name=ID? '{'
        alternatives+=ChoiceAlt+
    '}'
;

ChoiceAlt:
    ('when' guard=Expr)? ':' steps+=Step+
;

ParallelStep:
    'parallel' name=ID? '{'
        branches+=ParallelBranch+
    '}'
;

ParallelBranch:
    'branch' name=ID '{'
        steps+=Step+
    '}'
;

SyncStep:
    'sync' (mode=SyncMode)? ';'
;

ExpectStep:
    'expect' ('within' window=DurationLiteral)? condition=Expr ';'
;

///////////////////////////////////////////////////////
// 9) FSM: StateMachine, States (mit Modi), Transitions (Guards/Effekte)
///////////////////////////////////////////////////////

StateMachine:
    'statemachine' name=ID
    (annotations+=Annotation)*
    '{'
        items*=StateMachineItem
    '}'
;

StateMachineItem:
      Mode
    | State
    | StateTransition
    | VarDecl
    | ConstDecl
    | Trigger
;

Mode:
    'mode' name=ID ';'
;

State:
    'state' name=ID
    (annotations+=Annotation)*
    '{'
        ('entry' entry=ActionBlock)?
        ('exit'  exit=ActionBlock)?
        ('mode'  stateMode=[Mode])?
    '}'
;

StateTransition:
    'transition'
    'from' source=[State]
    'to'   target=[State]
    ('on' event=[Event])?
    ('when' guard=Expr)?
    ('do' effect=ActionBlock)?
    ';'
;

///////////////////////////////////////////////////////
// 10) ZEITLICHE CONSTRAINTS: Deadline, Period, Window, Cron
///////////////////////////////////////////////////////

TimeConstraint:
    'timeConstraint' name=ID '{'
        ('deadline'     '<=' max=DurationLiteral        ';')?
        ('period'       '='  period=DurationLiteral     ';')?
        ('responseTime' '<=' response=DurationLiteral   ';')?
        ('timeWindow'   '='  '[' start=TimeLiteral '..' end=TimeLiteral ']' ';')?
        ('cron'         '='  cron=CronLiteral           ';')?
    '}'
;

///////////////////////////////////////////////////////
// 11) KAUSALITÄT & PARALLELITÄT (Beziehungen auf Element-Ebene)
///////////////////////////////////////////////////////

Causality:
    'causality' name=ID '{'
        relations+=CausalRel+
    '}'
;

CausalRel:
    left=FQN '->' right=FQN ('label' lbl=STRING)? ';'
;

Concurrency:
    'concurrency' name=ID '{'
        rules+=ConcurrencyRule*
    '}'
;

ConcurrencyRule:
    kind=ConcurrencyKind a=FQN ',' b=FQN ';'
;

///////////////////////////////////////////////////////
// 12) LIFECYCLE (Create/Update/Delete) auf Objekttypen
///////////////////////////////////////////////////////

Lifecycle:
    'lifecycle' name=ID '{'
        ops+=LifecycleOp*
    '}'
;

LifecycleOp:
      CreateOp
    | UpdateOp
    | DeleteOp
;

CreateOp:
    'create' type=TypeRef 'as' varName=ID
    ('with' init=Expr)?
    ';'
;

UpdateOp:
    'update' target=QualifiedRef
    'set' field=ID '=' value=Expr
    ';'
;

DeleteOp:
    'delete' target=QualifiedRef ';'
;

QualifiedRef:
    base=FQN ('.' member=ID)*
;

///////////////////////////////////////////////////////
// 13) RÄUMLICHES MODELL: Zonen, Formen, Proximity, Kollision
///////////////////////////////////////////////////////

Zone:
    'zone' name=ID 'shape' shape=ShapeDef ';'
;

ShapeDef:
      CircleShape
    | RectShape
    | PolygonShape
;

CircleShape:
    'circle' '(' cx=FLOAT ',' cy=FLOAT ',' radius=FLOAT ')'
;

RectShape:
    'rect' '(' x=FLOAT ',' y=FLOAT ',' width=FLOAT ',' height=FLOAT ')'
;

PolygonShape:
    'polygon' '(' points+=Point (',' points+=Point)* ')'
;

Point:
    '(' x=FLOAT ',' y=FLOAT ')'
;

SpatialRule:
    'spatialRule' name=ID
    'when' condition=Expr
    'ensure' spatialConstraint=SpatialConstraint
    ';'
;

SpatialConstraint:
      'inside' zone=[Zone]
    | 'outside' zone=[Zone]
    | 'noCollision'
    | 'proximity' '(' ref=FQN ',' max=DistanceLiteral ')'
;

///////////////////////////////////////////////////////
// 14) PROPERTIES & NFRs (Safety/Liveness, Metriken, Traceability)
///////////////////////////////////////////////////////

PropertyDecl:
    'property' name=ID
    (annotations+=Annotation)*
    '{'
        spec=TemporalSpec ';'
    '}'
;

TemporalSpec:
      'ALWAYS' condition=Expr
    | 'EVENTUALLY' condition=Expr
    | 'WITHIN' bound=DurationLiteral ':' condition=Expr
    | 'LEADS_TO' a=Expr '->' b=Expr ('WITHIN' bound=DurationLiteral)?
;

NFRDecl:
    'nfr' name=ID
    (annotations+=Annotation)*
    '{'
        'metric' ':' metric=ID ';'
        'target' ':' comparator=CompOp value=Expr ';'
        ('scope' ':' scope=ID ';')?
    '}'
;

CompOp:
      '<='
    | '>='
    | '=='
    | '<'
    | '>'
    | '!='
;

///////////////////////////////////////////////////////
// 15) TESTS (Setup/Run/Assert/Teardown + Traceability)
///////////////////////////////////////////////////////

TestCase:
    'test' name=ID
    (annotations+=Annotation)*
    '{'
        ('trace' ':' reqId=STRING ';')?
        ('setup' setup=ActionBlock)?
        'run' target=TestTarget
        ('assert' assertExpr=Expr)?
        ('teardown' teardown=ActionBlock)?
    '}'
;

TestTarget:
      scenario=[MovementScenario]
    | statemachine=[StateMachine]
;

///////////////////////////////////////////////////////
// 16) SIMULATION & SCHEDULER
///////////////////////////////////////////////////////

SimulationConfig:
    'simulation' name=ID '{'
        ('tick'    '=' tick=DurationLiteral    ';')?
        ('seed'    '=' seed=INT                ';')?
        ('runtime' '=' runtime=DurationLiteral ';')?
        ('scheduler' '=' sched=[Scheduler]     ';')?
    '}'
;

Scheduler:
    'scheduler' name=ID '{'
        'policy' '=' policy=SchedulerPolicy ';'
        ('quantum' '=' quantum=DurationLiteral ';')?
        ('priority' '=' priority=INT ';')?
    '}'
;

SchedulerPolicy:
      'fifo'
    | 'roundrobin'
    | 'edf'
    | 'llf'
;

///////////////////////////////////////////////////////
// 17) ACTIONS & STATEMENTS (inkl. Senden/Emit/Assign/Create/Log)
///////////////////////////////////////////////////////

ActionBlock:
    '{' stmts+=ActionStmt* '}'
;

ActionStmt:
      Assignment ';'
    | FunctionCall ';'
    | EmitAction ';'
    | SendAction ';'
    | LogAction ';'
    | CreateOp
    | UpdateOp
    | DeleteOp
;

Assignment:
    target=QualifiedRef '=' value=Expr
;

FunctionCall:
    'call' function=[FunctionDef] '(' (args+=Expr (',' args+=Expr)*)? ')'
;

EmitAction:
    'emit' event=[Event] '(' (args+=Expr (',' args+=Expr)*)? ')'
;

SendAction:
    'send' msg=Expr 'via' channel=[Channel]
    ('delay' '=' delay=DurationLiteral)?
    ('dist'  '=' dist=[DistDef])?
;

LogAction:
    'log' msg=Expr
;

///////////////////////////////////////////////////////
// 18) AUSDRUCKSSYSTEM (vollwertig + Arrays, Ranges, Calls, Member)
///////////////////////////////////////////////////////

Expr:
    OrExpr
;

OrExpr:
    AndExpr ('||' AndExpr)*
;

AndExpr:
    RelExpr ('&&' RelExpr)*
;

RelExpr:
    AddExpr (op=RelOp right=AddExpr)?
;

RelOp:
      '=='
    | '!='
    | '<'
    | '<='
    | '>'
    | '>='
;

AddExpr:
    left=MulExpr (ops+=AddOp rights+=MulExpr)*
;

AddOp:
      '+'
    | '-'
;

MulExpr:
    left=UnaryExpr (ops+=MulOp rights+=UnaryExpr)*
;

MulOp:
      '*'
    | '/'
;

UnaryExpr:
    (ops+=UnaryOp)* operand=PostfixExpr
;

UnaryOp:
      '!'
    | '-'
;

PostfixExpr:
    primary=PrimaryExpr (postfix+=PostfixOp)*
;

PostfixOp:
      MemberAccess
    | CallSuffix
    | IndexSuffix
;

MemberAccess:
    '.' memberName=ID
;

CallSuffix:
    '(' (args+=Expr (',' args+=Expr)*)? ')'
;

IndexSuffix:
    '[' index=Expr ']'
;

PrimaryExpr:
      Literal
    | ref=QualifiedRef
    | ArrayLiteral
    | RangeLiteral
    | '(' Expr ')'
;

ArrayLiteral:
    '[' (items+=Expr (',' items+=Expr)*)? ']'
;

RangeLiteral:
    '[' start=Expr '..' end=Expr (':' step=Expr)? ']'
;

///////////////////////////////////////////////////////
// 19) LITERALE (Zahlen, Strings, Einheiten, Zeit, Cron, Probability)
///////////////////////////////////////////////////////

Literal:
      INT
    | FLOAT
    | STRING
    | 'true'
    | 'false'
    | DurationLiteral
    | DistanceLiteral
    | SpeedLiteral
    | AngleLiteral
    | TimeLiteral
    | ProbabilityLiteral
;

DurationLiteral:
    value=FLOAT unit=DurationUnit
;

DistanceLiteral:
    value=FLOAT unit=DistanceUnit
;

SpeedLiteral:
    value=FLOAT unit=SpeedUnit
;

AngleLiteral:
    value=FLOAT unit=AngleUnit
;

TimeLiteral:
    'T' hour=INT ':' minute=INT (':' second=INT)?
;

ProbabilityLiteral:
    FLOAT
;

CronLiteral:
    STRING
;

DurationUnit: 'ns' | 'us' | 'ms' | 's' | 'min' | 'h';
DistanceUnit: 'mm' | 'cm' | 'm' | 'km';
SpeedUnit: 'mps' | 'kmph';
AngleUnit: 'deg' | 'rad';

