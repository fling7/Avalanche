///////////////////////////////////////////////////////
// AVALANCHE-inspirierte Movement-DSL (Vollausbau)
///////////////////////////////////////////////////////

///////////////////////////////////////////////////////
// 0) BASIS (abstrakte "Named"-Superklasse für Refs)
///////////////////////////////////////////////////////
interface NamedElement:
    name=ID
;

///////////////////////////////////////////////////////
// 1) TOP-LEVEL: Model, Package, Imports, heterogene Elemente
///////////////////////////////////////////////////////

// NEU: vollwertiger Model-Rahmen
Model:
    'model' name=ID
    ('package' package=FQN)?                             // NEU
    (imports+=Import)*                                  // NEU
    '{'
        (elements+=Element)*                            // AUSGEBAUT: heterogene Liste
    '}'
;

FQN: ID ('.' ID)*;

// NEU: Import anderer Modelle/Artefakte
Import:
    'import' imported=[Model|FQN] ('as' alias=ID)? ';'
;

// NEU: Alle Top-Level-Elemente
Element:
      TypeDef | RecordType | EnumType | ConstDecl | VarDecl
    | DistDef | FunctionDef
    | Actor | Message | Channel                              // NEU: verteilte/agentenbasierte Aspekte
    | Event | Trigger                                        // NEU: formale Events/Trigger
    | MovementScenario                                       // AUSGEBAUT: Steps/Control-Flow
    | StateMachine                                           // AUSGEBAUT: FSM mit Entry/Exit/Effekten
    | TimeConstraint | Causality | Concurrency               // NEU: Zeit, Kausalität, Parallelität
    | Lifecycle                                              // NEU: Create/Update/Delete
    | Zone | SpatialRule                                     // NEU: räumliche Aspekte
    | PropertyDecl | NFRDecl                                 // NEU: Properties & NFRs
    | TestCase                                               // NEU: Test-Wrapper mit Setup/Assert/Teardown
    | SimulationConfig | Scheduler                           // NEU: Simulation & Scheduler
;

///////////////////////////////////////////////////////
// 2) ANNOTATIONEN (für NFP, Meta, Traceability)
///////////////////////////////////////////////////////

// NEU: universelle Annotationen
Annotation:
    '@' name=ID ('(' args+=AnnotationArg (',' args+=AnnotationArg)* ')')?
;

AnnotationArg:
    name=ID '=' value=Literal
;

///////////////////////////////////////////////////////
// 3) TYP-SYSTEM (vollständig: Alias, Record, Enum, Arrays)
///////////////////////////////////////////////////////

// NEU: Typalias
TypeDef implements NamedElement:
    'type' name=ID '=' target=TypeRef ';'
;

// NEU: Records
RecordType implements NamedElement:
    'record' name=ID '{'
        fields+=FieldDef*
    '}'
;

FieldDef:
    name=ID ':' type=TypeRef ('=' default=Expr)? ';'       // NEU: Default-Werte
;

// NEU: Enums
EnumType implements NamedElement:
    'enum' name=ID '{'
        literals+=ID (',' literals+=ID)*
    '}'
;

// AUSGEBAUT: Arrays & FQNs
TypeRef:
      BasicType
    | ArrayType
    | ref=[TypeDef|RecordType|EnumType|FQN]
;

BasicType:
    name=('int'|'float'|'bool'|'string'|'duration'|'distance'|'speed'|'angle'|'time'|'probability')
;

ArrayType:
    base=TypeRef '[]'
;

// NEU: Konstanten & Variablen (auch top-level)
ConstDecl implements NamedElement:
    'const' name=ID ':' type=TypeRef '=' value=Expr ';'
;

VarDecl implements NamedElement:
    'var' name=ID ':' type=TypeRef ('=' init=Expr)? ';'
;

///////////////////////////////////////////////////////
// 4) FUNKTIONEN / AKTIONEN (wiederverwendbare Aktionen)
///////////////////////////////////////////////////////

// NEU: Benutzerdefinierte Funktionen/Aktionen
FunctionDef implements NamedElement:
    'function' name=ID '(' (params+=Param (',' params+=Param)*)? ')'
    (':' returnType=TypeRef)?
    (annotations+=Annotation)*
    body=ActionBlock
;

Param:
    name=ID ':' type=TypeRef ('=' default=Expr)?
;

///////////////////////////////////////////////////////
// 5) DISTRIBUTIONEN (dist name = kind(...))
///////////////////////////////////////////////////////
DistDef implements NamedElement:
    'dist' name=ID '=' kind=ID '(' (params+=Expr (',' params+=Expr)*)? ')' ';'
    // z.B.: dist netDelay = normal(µ=20ms, σ=5ms);
;

///////////////////////////////////////////////////////
// 6) KOMMUNIKATION: Actor, Message, Channel, Ports
///////////////////////////////////////////////////////

// NEU: Nachrichtentypen (eigenständig, nicht nur Record)
Message implements NamedElement:
    'message' name=ID '{'
        (fields+=FieldDef)*
    '}'
;

// NEU: Actor mit Ports, Actions, optionalem Verhalten
Actor implements NamedElement:
    'actor' name=ID
    (annotations+=Annotation)*
    '{'
        (ports+=Port)*
        (vars+=VarDecl | consts+=ConstDecl | functions+=FunctionDef | triggers+=Trigger)*
    '}'
;

Port implements NamedElement:
    ('in'|'out') 'port' name=ID ':' message=[Message|ID]
    ('latency' '=' latency=DurationLiteral)?               // NEU: Latenz
    ('capacity' '=' capacity=INT)?                         // NEU: Kapazität
    ('loss' '=' loss=ProbabilityLiteral)?                  // NEU: Verlustwahrscheinlichkeit
    ';'
;

// NEU: Channels verbinden Ports
Channel implements NamedElement:
    'channel' name=ID '{'
        'from' src=[Port|FQN]
        'to'   dst=[Port|FQN]
        ('latency' '=' latency=DurationLiteral)?
        ('capacity' '=' capacity=INT)?
        ('loss' '=' loss=ProbabilityLiteral)?
    '}'
;

///////////////////////////////////////////////////////
// 7) EVENTS & TRIGGER (mit Guards, Payload, Verteilungen)
///////////////////////////////////////////////////////

// NEU: Formale Events, an die Trigger gekoppelt werden
Event implements NamedElement:
    'event' name=ID
    '(' (params+=Param (',' params+=Param)*)? ')'
    '{'
        ('type' ':' eventType=ID ';')?                     // frei (z.B. "external", "timer", "sensor")
        ('probability' '=' prob=ProbabilityLiteral ';')?   // optional
        ('arrival' '=' dist=[DistDef|ID] ';')?             // Ankunftsverteilung
        ('payload' ':' payloadType=TypeRef ';')?           // falls param. Payload gewünscht
    '}'
;

// AUSGEBAUT: Trigger strikt an Events, mit Guard+Action
Trigger implements NamedElement:
    'trigger' name=ID?
    'on' event=[Event|ID]
    ('when' guard=Expr)?
    'do' action=ActionBlock
;

///////////////////////////////////////////////////////
// 8) SZENARIEN & STEPS (Action, Choice, Parallel, Wait, Sync, Expect)
///////////////////////////////////////////////////////
MovementScenario implements NamedElement:
    'scenario' name=ID
    (annotations+=Annotation)*
    '{'
        (locals+=VarDecl | locals+=ConstDecl)*
        (steps+=Step)*
    '}'
;

// AUSGEBAUT: zusätzliche Step-Formen
Step:
      StepDuration
    | StepDistance
    | ActionStep
    | WaitStep
    | ChoiceStep
    | ParallelStep
    | SyncStep             // NEU
    | ExpectStep           // NEU (Erwartungen/Assertions im Ablauf)
;

// ALT (aus eurer Grammatik, syntaktisch leicht harmonisiert)
StepDuration implements NamedElement:
    'stepDuration' name=ID?
    'for' duration=DurationLiteral
    ('using' distribution=[DistDef|ID])?
    ';'
;

// ALT
StepDistance implements NamedElement:
    'stepDistance' name=ID?
    'distance' distance=DistanceLiteral
    ('using' distribution=[DistDef|ID])?
    ';'
;

// NEU: generischer Aktionsschritt
ActionStep implements NamedElement:
    'step' name=ID 'do' action=ActionBlock
;

// NEU: warten (zeitlich oder bis Event)
WaitStep implements NamedElement:
    'wait'
    (('for' duration=DurationLiteral) | ('until' event=[Event|ID]))
    ';'
;

// NEU: Verzweigung
ChoiceStep implements NamedElement:
    'choice' name=ID? '{'
        alternatives+=ChoiceAlt+
    '}'
;

ChoiceAlt:
    ('when' guard=Expr)? ':' steps+=Step+
;

// NEU: Parallelität
ParallelStep implements NamedElement:
    'parallel' name=ID? '{'
        branches+=ParallelBranch+
    '}'
;

ParallelBranch implements NamedElement:
    'branch' name=ID '{'
        steps+=Step+
    '}'
;

// NEU: explizite Synchronisations‑Barriere
SyncStep:
    'sync' ('all' | 'any')? ';'
;

// NEU: Erwartung/Assertion innerhalb eines Szenarios
ExpectStep implements NamedElement:
    'expect' ('within' window=DurationLiteral)? condition=Expr ';'
;

///////////////////////////////////////////////////////
// 9) FSM: StateMachine, States (mit Modi), Transitions (Guards/Effekte)
///////////////////////////////////////////////////////
StateMachine implements NamedElement:
    'statemachine' name=ID
    (annotations+=Annotation)*
    '{'
        (modes+=Mode)*                                     // NEU: optionale Modi
        (states+=State)+
        (transitions+=StateTransition)*
        (locals+=VarDecl | locals+=ConstDecl | triggers+=Trigger)*
    '}'
;

// NEU: Betriebsmodi (leichtgewichtig)
Mode implements NamedElement:
    'mode' name=ID ';'
;

// AUSGEBAUT: Entry/Exit-Aktionen
State implements NamedElement:
    'state' name=ID
    (annotations+=Annotation)*
    '{'
        ('entry' entry=ActionBlock)?
        ('exit'  exit=ActionBlock)?
        ('mode'  stateMode=[Mode|ID])?                     // optionaler Modus
    '}'
;

// AUSGEBAUT: Guard, Effekt, optionales Event
StateTransition implements NamedElement:
    'transition'
    'from' source=[State|ID]
    'to'   target=[State|ID]
    ('on' event=[Event|ID])?
    ('when' guard=Expr)?
    ('do' effect=ActionBlock)?
    ';'
;

///////////////////////////////////////////////////////
// 10) ZEITLICHE CONSTRAINTS: Deadline, Period, Window, Cron
///////////////////////////////////////////////////////
TimeConstraint implements NamedElement:
    'timeConstraint' name=ID
    '{'
        ('deadline'     '<=' max=DurationLiteral        ';')?
        ('period'       '='  period=DurationLiteral     ';')?
        ('responseTime' '<=' response=DurationLiteral   ';')?
        ('timeWindow'   '='  '[' start=TimeLiteral '..' end=TimeLiteral ']' ';')?
        ('cron'         '='  cron=CronLiteral           ';')?
    '}'
;

///////////////////////////////////////////////////////
// 11) KAUSALITÄT & PARALLELITÄT (Beziehungen auf Element-Ebene)
///////////////////////////////////////////////////////

// NEU: kausale Beziehungen zwischen Elementen (Steps, States, Events, Actions)
Causality implements NamedElement:
    'causality' name=ID '{'
        relations+=CausalRel+
    '}'
;

CausalRel:
    left=[NamedElement|FQN] '->' right=[NamedElement|FQN] ('label' lbl=STRING)? ';'
;

// NEU: Parallelitäts- und Exklusivitätsdefinitionen
Concurrency implements NamedElement:
    'concurrency' name=ID '{'
        (rules+=ConcurrencyRule)*
    '}'
;

ConcurrencyRule:
      'parallel'  a=[NamedElement|FQN] ',' b=[NamedElement|FQN] ';'
    | 'exclusive' a=[NamedElement|FQN] ',' b=[NamedElement|FQN] ';'
    | 'alternative' a=[NamedElement|FQN] ',' b=[NamedElement|FQN] ';'
;

///////////////////////////////////////////////////////
// 12) LIFECYCLE (Create/Update/Delete) auf Objekttypen
///////////////////////////////////////////////////////
Lifecycle implements NamedElement:
    'lifecycle' name=ID '{'
        (ops+=LifecycleOp)*
    '}'
;

LifecycleOp:
      CreateOp
    | UpdateOp
    | DeleteOp
;

CreateOp:
    'create' type=TypeRef 'as' varName=ID
    ('with' init=Expr)?
    ';'
;

UpdateOp:
    'update' target=QualifiedRef
    'set' field=ID '=' value=Expr
    ';'
;

DeleteOp:
    'delete' target=QualifiedRef ';'
;

QualifiedRef:
    base=[NamedElement|FQN] ('.' member=ID)*
;

///////////////////////////////////////////////////////
// 13) RÄUMLICHES MODELL: Zonen, Formen, Proximity, Kollision
///////////////////////////////////////////////////////
Zone implements NamedElement:
    'zone' name=ID 'shape' shape=ShapeDef ';'
;

ShapeDef:
      CircleShape
    | RectShape
    | PolygonShape
;

CircleShape:
    'circle' '(' cx=FLOAT ',' cy=FLOAT ',' radius=FLOAT ')'
;

RectShape:
    'rect' '(' x=FLOAT ',' y=FLOAT ',' width=FLOAT ',' height=FLOAT ')'
;

PolygonShape:
    'polygon' '(' points+=Point (',' points+=Point)* ')'
;

Point:
    '(' x=FLOAT ',' y=FLOAT ')'
;

// NEU: räumliche Regeln
SpatialRule implements NamedElement:
    'spatialRule' name=ID
    'when' condition=Expr
    'ensure' spatialConstraint=SpatialConstraint
    ';'
;

SpatialConstraint:
      'inside' zone=[Zone|ID]
    | 'outside' zone=[Zone|ID]
    | 'noCollision'
    | 'proximity' '(' ref=[NamedElement|FQN] ',' max=DistanceLiteral ')'  // NEU: Proximity
;

///////////////////////////////////////////////////////
// 14) PROPERTIES & NFRs (Safety/Liveness, Metriken, Traceability)
///////////////////////////////////////////////////////

// NEU: temporale Properties (leichtgewichtig)
PropertyDecl implements NamedElement:
    'property' name=ID
    (annotations+=Annotation)*
    '{'
        // Beispiele: ALWAYS p, EVENTUALLY q, WITHIN T: r
        (spec=TemporalSpec) ';'
    '}'
;

TemporalSpec:
      'ALWAYS' condition=Expr
    | 'EVENTUALLY' condition=Expr
    | 'WITHIN' bound=DurationLiteral ':' condition=Expr
    | 'LEADS_TO' a=Expr '->' b=Expr ('WITHIN' bound=DurationLiteral)?
;

// NEU: Nichtfunktionale Anforderungen (z.B. Latenz, Durchsatz)
NFRDecl implements NamedElement:
    'nfr' name=ID
    (annotations+=Annotation)*
    '{'
        'metric' ':' metric=ID ';'             // z.B. latency, throughput, energy
        'target' ':' comparator=CompOp value=Expr ';' // <= 100ms, >= 30fps, etc.
        ('scope' ':' scope=ID ';')?             // optional: z.B. pro Scenario/Actor/Port
    '}'
;

CompOp: ('<='|'>='|'=='|'<'|'>'|'!=');

///////////////////////////////////////////////////////
// 15) TESTS (Setup/Run/Assert/Teardown + Traceability)
///////////////////////////////////////////////////////
TestCase implements NamedElement:
    'test' name=ID
    (annotations+=Annotation)*
    '{'
        ('trace' ':' reqId=STRING ';')?          // NEU: Traceability
        ('setup' setup=ActionBlock)?
        'run' target=(scenario=[MovementScenario|ID] | sm=[StateMachine|ID])
        ('assert' assertExpr=Expr)?
        ('teardown' teardown=ActionBlock)?
    '}'
;

///////////////////////////////////////////////////////
// 16) SIMULATION & SCHEDULER
///////////////////////////////////////////////////////
SimulationConfig implements NamedElement:
    'simulation' name=ID
    '{'
        ('tick'    '=' tick=DurationLiteral    ';')?
        ('seed'    '=' seed=INT                ';')?
        ('runtime' '=' runtime=DurationLiteral ';')?
        ('scheduler' '=' sched=[Scheduler|ID]  ';')?
    '}'
;

// NEU: Scheduler-Konfigurationen
Scheduler implements NamedElement:
    'scheduler' name=ID '{'
        'policy' '=' policy=('fifo'|'roundrobin'|'edf'|'llf') ';'
        ('quantum' '=' quantum=DurationLiteral ';')?     // z.B. für RR
        ('priority' '=' priority=INT ';')?
    '}'
;

///////////////////////////////////////////////////////
// 17) ACTIONS & STATEMENTS (inkl. Senden/Emit/Assign/Create/Log)
///////////////////////////////////////////////////////
ActionBlock:
    '{' (stmts+=ActionStmt)* '}'
;

ActionStmt:
      Assignment ';'
    | ActionCall ';'
    | EmitAction ';'
    | SendAction ';'
    | LogAction ';'
    | CreateOp
    | UpdateOp
    | DeleteOp
;

Assignment:
    target=QualifiedRef '=' value=Expr
;

ActionCall:
    name=[FunctionDef|FQN] '(' (args+=Expr (',' args+=Expr)*)? ')'
;

EmitAction:
    'emit' event=[Event|ID] '(' (args+=Expr (',' args+=Expr)*)? ')'
;

SendAction:
    'send' msg=Expr 'via' ch=[Channel|ID]
    ('delay' '=' delay=DurationLiteral)? ('dist' '=' dist=[DistDef|ID])?
;

LogAction:
    'log' msg=Expr
;

///////////////////////////////////////////////////////
// 18) AUSDRUCKSSYSTEM (vollwertig + Arrays, Ranges, Calls, Member)
///////////////////////////////////////////////////////
Expr:
    OrExpr
;

OrExpr:
    AndExpr ('||' AndExpr)*
;

AndExpr:
    RelExpr ('&&' RelExpr)*
;

RelExpr:
    AddExpr (opRel=('=='|'!='|'<'|'<='|'>'|'>=') AddExpr)?
;

AddExpr:
    MulExpr (opAdd=('+'|'-') MulExpr)*
;

MulExpr:
    UnaryExpr (opMul=('*'|'/') UnaryExpr)*
;

UnaryExpr:
      ('!'|'-') UnaryExpr
    | PostfixExpr
;

PostfixExpr:
    PrimaryExpr (postfix+=PostfixOp)*
;

PostfixOp:
      MemberAccess
    | CallSuffix
    | IndexSuffix
;

MemberAccess:
    '.' memberName=ID
;

CallSuffix:
    '(' (args+=Expr (',' args+=Expr)*)? ')'
;

IndexSuffix:
    '[' index=Expr ']'
;

PrimaryExpr:
      Literal
    | ref=QualifiedRef
    | ArrayLiteral
    | RangeLiteral
    | '(' Expr ')'
;

ArrayLiteral:
    '[' (items+=Expr (',' items+=Expr)*)? ']'
;

RangeLiteral:
    '[' start=Expr '..' end=Expr (':' step=Expr)? ']'
;

///////////////////////////////////////////////////////
// 19) LITERALE (Zahlen, Strings, Einheiten, Zeit, Cron, Probability)
///////////////////////////////////////////////////////
Literal:
      INT
    | FLOAT
    | STRING
    | 'true'
    | 'false'
    | DurationLiteral
    | DistanceLiteral
    | SpeedLiteral
    | AngleLiteral
    | TimeLiteral
    | ProbabilityLiteral
;

DurationLiteral:
    // Beispiele: 50ms, 2s, 5min, 1h
    value=FLOAT unit=('ns'|'us'|'ms'|'s'|'min'|'h')
;

DistanceLiteral:
    // Beispiele: 10cm, 2.5m, 1km
    value=FLOAT unit=('mm'|'cm'|'m'|'km')
;

SpeedLiteral:
    // Beispiele: 10mps, 50kmph
    value=FLOAT unit=('mps'|'kmph')
;

AngleLiteral:
    // Beispiele: 90deg, 1.57rad
    value=FLOAT unit=('deg'|'rad')
;

TimeLiteral:
    // vereinfachte Form, kann bei Bedarf erweitert werden (ISO-Zeit als STRING ist Alternative)
    'T' hour=INT ':' minute=INT (':' second=INT)?          // z.B. T13:45[:30]
;

ProbabilityLiteral:
    FLOAT                                                  // 0.0 .. 1.0 erwartet
;

CronLiteral:
    STRING                                                 // "*/5 * * * *" etc.
;

///////////////////////////////////////////////////////
// 20) TERMINALS (ggf. im Projekt anpassen)
///////////////////////////////////////////////////////
terminal ID: /[a-zA-Z_][a-zA-Z0-9_]*/;
terminal INT: /[0-9]+/;
terminal FLOAT: /[0-9]+(\.[0-9]+)?/;
terminal STRING: /"([^"\\]|\\.)*"/;
